<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
  <title>History - VCS</title>
</head>
<body>
    <nav>
        <a href="index.html">Main page</a>
        <a href="history.html">History</a>
        <a href="trends.html">Trends</a>
    </nav>
    <h2>Timeline of Key VCS Systems</h2>
    <p>The history of version control systems represents an evolution from simple, local tools to globally distributed collaboration platforms.</p>
    <ul>
        <li><b>RCS (Revision Control System) (1982):</b> Created by Walter Tichy, RCS automated change tracking for individual files. It operated locally (lacking network support) and stored differences between versions (deltas) to conserve storage space.</li>
        <li><b>CVS (Concurrent Versions System) (1986):</b> Developed by Dick Grune as a front-end for RCS, CVS introduced the client-server model. It was the first system to allow multiple developers to collaborate concurrently on entire projects over a network. It gained significant popularity in the 1990s but suffered from major drawbacks, such as the lack of atomic commits (changes could be only partially saved) and problematic branch management.</li>
        <li><b>Subversion (SVN) (2000):</b> Created by CollabNet as a direct successor to CVS, designed to fix its flaws. SVN introduced key improvements: atomic commits (all changes were part of a single "all-or-nothing" transaction), better file renaming/moving tracking, and more efficient network operation. SVN became the dominant VCS in the mid-2000s. Critically, however, SVN remained a centralized system (CVCS)—there was a single central repository with which all users communicated.</li>
        <li><b>Git and Mercurial (2005):</b> 2005 was a watershed year. After the commercial VCS (BitKeeper) used by the Linux kernel developers became unavailable, Linus Torvalds created Git as a new, distributed VCS (DVCS). Almost simultaneously, Matt Mackall released Mercurial, also a DVCS. Both systems fundamentally changed the development model by giving every developer a full copy of the repository. Git quickly achieved market dominance.</li>
        <li><b>GitHub launched (2008):</b> GitHub introduced a web-based collaboration platform built on Git, making it easier to share and contribute to projects. It added features like pull requests, issue tracking, and social interaction between developers. GitHub and similar platforms such as Bitbucket and GitLab greatly accelerated Git’s global adoption.</li>

    <li><b>Wide adoption of Git (2010s):</b> During this decade, most teams and open-source projects migrated from older tools like CVS and SVN to Git. Even large enterprises moved from centralized systems such as TFS or Perforce. Distributed version control became the new standard across the software industry.</li>

    <li><b>GitOps and modern practices (Late 2010s):</b> The term GitOps was introduced by Weaveworks in 2017, promoting Git as the single source of truth for managing infrastructure and deployments. Integration with CI/CD pipelines became mainstream, and cloud-hosted VCS platforms grew in popularity among developers.</li>

    <li><b>AI and large-scale collaboration (2020s):</b> By the 2020s, GitHub and similar services reached massive scale, with over 100 million developers using them. AI tools such as GitHub Copilot began assisting with code writing and review. Version control remains central to DevOps and large-scale, cloud-based collaboration.</li>

    </ul>
    <h2>How Distributed VCS (DVCS) Changed the Game</h2>
    <p>The difference between centralized (CVCS) and distributed (DVCS) version control systems is fundamental and revolutionized how teams work.</p>
    <h4>The Centralized Model (CVCS), e.g., SVN:</h4>
    <ul>
        <li>A single, central repository exists on a server, holding the "official" version of the code.</li>
        <li>Developers check out changes from this server and commit their changes directly back to it.</li>
        <li><b>Drawbacks: </b>Requires a constant network connection to work (even for commits). The server is a single point of failure (if it goes down, work stops). Operations like branching were "heavyweight" and cumbersome, leading teams to avoid them.</li>
    </ul>
    <h2>The Distributed Model (DVCS), e.g., Git:</h2>
    <ul>
        <li>In a DVCS, every developer has a full copy (a clone) of the entire repository on their local machine, including its complete history.</li>
        <li>There is no "master" server by definition—every clone is a complete backup. A server (e.g., on GitHub) is treated as "central" merely by convention to facilitate synchronization.</li>
    </ul>
    <h2>The Key Change: The Branching and Merging Model The DVCS revolution lay in its treatment of branches and code merging:</h2>
    <ol>
        <li>Offline Work: Developers commit changes locally to their own repository copy. This is an instantaneous, offline operation. Synchronization (push/pull) with others is a separate, subsequent step.</li>
        <li>Cheap and Fast Branching: In Git, creating a new branch is a near-instantaneous and "cheap" operation (it consumes minimal resources).</li>
        <li>Merging as a Core Concept: Because everyone works locally on their own branches, merging changes is a fundamental and frequent operation, one for which DVCS tools are exceptionally well-designed.</li>
    </ol>
    <p><b>The Result: </b>This model enabled massive parallel development and non-linear workflows. Teams could fearlessly create separate branches for every new feature, experiment, or bug fix (so-called feature branching), work on them in isolation, and then safely merge them into the main development line. This flexibility and speed became the new standard in software development.</p>
</body>
</html>
